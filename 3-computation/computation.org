#+TITLE: Computation
#+AUTHOR: Yousef Ghazy
#+DESCRIPTION: Objects, types and values
#+OPTIONS: toc:2

الcomputation هنا معناها الstructure بتاع العمليات اللي بتحصل علي البيانات، في المحاضره دي هنوضح ازاي تحسب value من مجموعه operands واللي بيتقال عليه (expression)، ازاي تختار انهي statements تتنفذ امتي (selection)، ازاي تنفذ نفس الcomputation علي عده قيم او values، وازاي نعمل برامج صغيره جوا البرنامج بتاعنا (functions)
* الفهرس :toc:
- [[#الcomputation][الcomputation]]
- [[#الهدف-والtools-اللي-بنستخدمها][الهدف والtools اللي بنستخدمها]]

* الcomputation
احنا نوعا ما نقدر نقول ان كل اللي البرنامج بيعمله هو computation؛ يعني بياخد شوية inputs وبيطلع شوية output. في الآخر، إحنا بنسمي الجهاز اللي بيشغّل البرنامج ده computer.

النظرة دي منطقية لو فهمنا "input" و"output" بشكل واسع شوية.

الـinput ممكن ييجي من keyboard، أو mouse، أو touch screen، أو من files، أو من برامج تانية، أو حتى من أجزاء تانية من نفس البرنامج.
وفيه كمان مصادر input تانيه زي: music keyboards، video recorders، network connections، temperature sensors، image sensors، وpower supplies.

علشان يتعامل البرنامج مع الـinput، غالبًا بيبقى فيه بيانات جواه، أحيانًا بنسميها data structures أو state بتاع البرنامج.
مثلاً، برنامج تقويم (calendar) ممكن يبقى جواه قايمة بالأعياد في بلاد مختلفة، وقايمة بمواعيدك.

بعض البيانات دي بتكون جزء من البرنامج من الأول، والبعض التاني بيتكون مع الوقت لما البرنامج يقرأ input ويجمع منه معلومات.
يعني، برنامج الـcalendar هيكوّن قايمة المواعيد بتاعتك من الـinput اللي إنت بتدخّله.

في الحالة دي، الـinput الأساسي هو طلبك إنك تشوف أيام أو شهور معينة (غالبا بكليك بالماوس)،
وكمان لما تدخل مواعيد جديدة (غالبًا عن طريق الكتابة بالكيبورد).
الـoutput هو عرض التقويم والمواعيد، وكمان الأزرار والتعليمات اللي بتظهرلك على الشاشة.
وممكن كمان البرنامج يبعتلك تذكيرات، أو يزامن بياناتك مع نسخ تانية من نفس البرنامج.

زي ما الـinput بييجي من مصادر كتير، كمان الـoutput بيروح لأماكن مختلفة.
ممكن يروح للشاشة، أو لملفات، أو من خلال network، أو لأجهزة تانية، أو لبرماج تانيه، أو لأجزاء تانية من نفس البرنامج.

من وجهة نظر البرمجة، أكتر أنواع الـinput/output أهمية وإثارة للاهتمام هي اخر اتنين، من برنامج لبرنامج ومن جذء من البرنامج لجذء اخر من نفس البرنامج.

ومعظم الكورس ده ممكن نعتبره شرح للنوع الأخير:
إزاي نكتب برنامج على شكل مجموعة أجزاء بتشتغل مع بعض، وبتشارك وتتبادل البيانات؟
دي من أهم الأسئلة في البرمجة.

الاختصار I/O معناه "input/output".
وفي السياق ده، الـoutput من جزء معين من الكود هو الـinput للجزء اللي بعده.
والأجزاء دي بتشارك بيانات مخزنة في الmemory، أو على مساحات تخزين زي الهاردات، أو بتتنقل بال network connections.

ولما نقول "أجزاء من البرنامج"، بنقصد حاجات زي:

1) مثلا function بتاخد شوية arguments وتطلع نتيجة (زي حساب الجذر التربيعي لرقم).
2) أو function بتعمل فعل معين على حاجة مادية (زي رسم خط على الشاشة).
3) أو function بتعدّل جدول معين في البرنامج (زي إضافة اسم جديد لقايمة عملاء).

ولما نقول "input" و"output"، غالبًا بنقصد المعلومات اللي داخلة أو خارجة من computer،
بس زي ما شُفت، ممكن كمان نقصد المعلومات اللي جزء من البرنامج بيستقبلها أو بينتجها.

الـinputs للجزء ده بنسميها غالبًا arguments، والـoutputs بنسميها results.

والمقصود بـcomputation ببساطة هو إنتاج output معين بناءً على input معين،
زي إنتاج الرقم 49 من الرقم 7 باستخدام function اسمها pow (اختصار لpower).

وبالمناسبة، معلومة ممكن تهمك: لحد الخمسينات، كلمة "computer" كانت بتوصف شخص بيعمل computations يدويًا،
زي المحاسب أو الملاح أو الفيزيائي.
دلوقتي إحنا بنخلّي الـcomputers (بأشكالها المختلفة زي الموبايلات) تعمل الحسابات دي بدلنا.

* الهدف والtools اللي بنستخدمها
شغلانتنا كمبرمجين هي إننا نعبّر عن الـcomputations:
- بشكل صحيح (Correctly)
- بشكل بسيط (Simply)
- بشكل فعال (Efficiently)

خلي بالك من ترتيب القيم دي:
مافيش فايدة من برنامج سريع لو بيطلع نتايج غلط.
وبرضو، البرنامج السريع اللي بيطلع نتايج صحيحه ممكن يبقى معقد لدرجة إنه لازم يتكتب من أول وجديد علشان نعمل إصدار جديد منه.
لأن افتكر دايمًا إن البرامج المفيدة بيتم تعديلها بشكل مستمر علشان تواكب احتياجات جديدة أو أجهزة جديدة.
عشان كده، لازم أي برنامج – وأي جزء من البرنامج – يكون بسيط قدر الإمكان في أداء وظيفته.

مثلًا، افترض إنك كتبت برنامج ممتاز لتعليم الحساب للأطفال في مدرسة، لكن الهيكل الداخلي بتاعه فوضوي.
كنت بتتكلم مع الأطفال بأي لغة؟ إنجليزي؟ إنجليزي وإسباني؟
طب لو أنا عايز أستخدمه في فنلندا؟ أو في الكويت؟
هتغير اللغة الطبيعية اللي البرنامج بيخاطب بيها الطفل إزاي؟
لو الهيكل الداخلي للبرنامج فوضوي، العملية اللي منطقها بسيط (لكن في الواقع بتكون صعبة جدًا) زي تغيير لغة البرنامج، هتبقى مستحيلة.

الاهتمام بالبساطة والفعالية بيبدأ أول ما نقرر نكتب كود للناس، ونتحمل مسؤولية إننا نكتبه بشكل كويس. لازم نتحمل المسؤولية دي لما نقرر نبقى محترفين.
بشكل عملي، ده معناه إننا ماينفعش نرمي كود عشوائي لحد ما "يشتغل"، لازم نهتم بالهيكل أو الstructure بتاع الكود.

وعلى عكس المتوقع، الاهتمام بالـstructure وجودة الكود هو غالبًا أسرع طريق علشان نخلي البرنامج يشتغل.
لما البرمجة تتعمل بشكل صح، الاهتمام ده بيقلل من أكتر جزء بضان في البرمجة: debugging.
يعني، هيكل الكود الجيد وقت الكتابة ممكن يقلل عدد الأخطاء، والوقت اللي هنقضيه بندوّر على الأخطاء ونصلحها.

أهم أداة عندنا لتنظيم البرنامج – وتنظيم تفكيرنا وقت البرمجة – هي إننا نقسم المشكله الكبيره لمشاكل صغيره.
الطريقة دي ليها شكلين رئيسيين:

+ الAbstraction:
  بنخبي التفاصيل اللي مش محتاجين نعرفها علشان نستخدم حاجة (يعني "implementation details") ورا interface يكون بسيط وعام.
  مثال: بدل ما ندخل في تفاصيل عمليه الsorting دليل تليفونات (ودي تفاصيل ممكن تكتب عنها كتب)،
  إحنا ببساطة بنستدعي sort algorithm من الC++ standard library.
  كل اللي محتاجين نعرفه هو إزاي ننادي الfunction اللي اسمها =(b)std::sort= ، والـb هو دليل التليفونات.
  مثال تاني: إحنا مش بنتعامل مباشرة مع الmemory – لأنها فوضوية – بل بنستخدم typed variables، أو vectors، أو maps.
+ تكنيك Divide-and-conquer:
  بنقسم المشكلة الكبيرة لمجموعة مشاكل أصغر. مثال: لو عايز تبني قاموس، ممكن تقسم المهمة لثلاثة:
  - اقرأ البيانات
  - رتّب البيانات
  - اطبع البيانات
  كل مهمة من دول أبسط بكتير من المشكلة الأصلية.

ليه الطريقة دي فعالة؟
رغم إن البرنامج اللي متقسم ممكن يكون أطول شوية من برنامج كله محشور ومتلصم مع بعضه بأعجوبه.
بس الحقيقة إننا كبشر مش بنعرف نتعامل كويس مع المشاكل الكبيرة.
في البرمجة – وفي الحياة – بنحل المشاكل الكبيرة عن طريق تقسيمها لأجزاء أصغر وأسهل.
يعني مثلًا، برنامج فيه 1000 سطر ممكن يكون فيه أكتر من 10 أضعاف عدد الأخطاء اللي في برنامج من 100 سطر.
علشان كده بنحاول نخلي البرنامج الطويل مكون من أجزاء صغيرة، كل جزء أقل من 100 سطر. وكل جذء بيتعامل مع مشكله معينه وبيحلها وملوش علاقه بالمشاكل التانيه.

في البرامج الكبيرة اللي بتوصل مئات الألاف او حتي ملايين السطور من الكود.
استخدام abstraction وdivide-and-conquer مش مجرد اختيار، دي ضرورة.
إحنا ببساطة مش قادرين نكتب ونحافظ على برامج ضخمة ومترابطة في كود واحد.
ممكن تبص لبقية الكورس ده على إنه سلسلة طويلة من أمثلة لمشاكل محتاجة تتقسم،
ومعها الأدوات والأساليب اللي تساعدك تعمل كده.

لاحظ التركيز على structure وorganization:
إنت مش هتطلع كود كويس لمجرد إنك كتبت سطور كتير.
كتير جدا من المبتدئين والهاكرز بيفتخروا بعدد السطور اللي كتبوها، فاكرين ان كل لما البرنامج كبر دا بيديله هيبه اكتر.
بس متتفاجئش لما تعرض البرنامج بتاعك اللي بيتكون من الف سطر علي مبرمج محترف وتلاقيه رجعهولك بعد حذف 900 سطر واضافه 200 علشان يكون الناتج 300 سطر بس.
وفي عالم البرمجه، لو في برنامجين بيعملوا نفس الشيئ بس واحد منهم بيتكون من عدد سطور اقل، غالبا البرنامج الأصغر بيكون افضل.

ليه بنتكلم عن ده دلوقتي؟
علشان في المرحلة دي، انت لسه معندكش اي فكره يعني ايه كود حقيقي.
وفيها علي الأقل شهور قبل ما تكتب كود ممكن الناس تعتمد عليه في شغلهم أو حياتهم.
إحنا بنقول الكلام ده علشان نوجّه تركيزك من الأول في الأتجاه الصح والmindset الصح في تصميم البرامج.

من المغري إنك تجري بسرعة وتركز على الحاجات العملية اللي هتستخدمها فورًا،
وتتجاهل الأجزاء الsoft أو النظريه من فن تطوير البرمجيات.
لكن المبرمجين والمصممين المحترفين (وأغلبهم اتعلم ده بالطريقة الصعبة، وهي نفس الطريقه اللي هنحاول نعلمك بيها)
عارفين إن الاهتمام بالstructure هو اهم شيئ في الsoftware الجيد،
وإن تجاهله بيؤدي لكوارث مكلفة.

من غير structure، فـإنت – بشكل مجازي – بتبني بطوب طين.
ينفع؟ آه، لكن عمرك ما هتوصل للدور العاشر (الطوب الطين ما يقدرش يشيل).

لو عندك طموح تبني حاجة كبيرة أو دائمة،
لازم تهتم بهيكل الكود وتنظيمه من الأول،
بدل ما تضطر تتعلمه بعد ما تقع.
