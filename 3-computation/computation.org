#+TITLE: Computation
#+AUTHOR: Yousef Ghazy
#+DESCRIPTION: Objects, types and values
#+OPTIONS: toc:2

الcomputation هنا معناها الstructure بتاع العمليات اللي بتحصل علي البيانات، في المحاضره دي هنوضح ازاي تحسب value من مجموعه operands واللي بيتقال عليه (expression)، ازاي تختار انهي statements تتنفذ امتي (selection)، ازاي تنفذ نفس الcomputation علي عده قيم او values، وازاي نعمل برامج صغيره جوا البرنامج بتاعنا (functions)
* الفهرس :toc:
- [[#الcomputation][الcomputation]]
- [[#الهدف-والtools-اللي-بنستخدمها][الهدف والtools اللي بنستخدمها]]
- [[#الexpressions][الexpressions]]
- [[#الconstant-expressions][الconstant expressions]]
- [[#الoperators][الoperators]]

* الcomputation
احنا نوعا ما نقدر نقول ان كل اللي البرنامج بيعمله هو computation؛ يعني بياخد شوية inputs وبيطلع شوية output. في الآخر، إحنا بنسمي الجهاز اللي بيشغّل البرنامج ده computer.

النظرة دي منطقية لو فهمنا "input" و"output" بشكل واسع شوية.

الـinput ممكن ييجي من keyboard، أو mouse، أو touch screen، أو من files، أو من برامج تانية، أو حتى من أجزاء تانية من نفس البرنامج.
وفيه كمان مصادر input تانيه زي: music keyboards، video recorders، network connections، temperature sensors، image sensors، وpower supplies.

علشان يتعامل البرنامج مع الـinput، غالبًا بيبقى فيه بيانات جواه، أحيانًا بنسميها data structures أو state بتاع البرنامج.
مثلاً، برنامج تقويم (calendar) ممكن يبقى جواه قايمة بالأعياد في بلاد مختلفة، وقايمة بمواعيدك.

بعض البيانات دي بتكون جزء من البرنامج من الأول، والبعض التاني بيتكون مع الوقت لما البرنامج يقرأ input ويجمع منه معلومات.
يعني، برنامج الـcalendar هيكوّن قايمة المواعيد بتاعتك من الـinput اللي إنت بتدخّله.

في الحالة دي، الـinput الأساسي هو طلبك إنك تشوف أيام أو شهور معينة (غالبا بكليك بالماوس)،
وكمان لما تدخل مواعيد جديدة (غالبًا عن طريق الكتابة بالكيبورد).
الـoutput هو عرض التقويم والمواعيد، وكمان الأزرار والتعليمات اللي بتظهرلك على الشاشة.
وممكن كمان البرنامج يبعتلك تذكيرات، أو يزامن بياناتك مع نسخ تانية من نفس البرنامج.

زي ما الـinput بييجي من مصادر كتير، كمان الـoutput بيروح لأماكن مختلفة.
ممكن يروح للشاشة، أو لملفات، أو من خلال network، أو لأجهزة تانية، أو لبرماج تانيه، أو لأجزاء تانية من نفس البرنامج.

من وجهة نظر البرمجة، أكتر أنواع الـinput/output أهمية وإثارة للاهتمام هي اخر اتنين، من برنامج لبرنامج ومن جذء من البرنامج لجذء اخر من نفس البرنامج.

ومعظم الكورس ده ممكن نعتبره شرح للنوع الأخير:
إزاي نكتب برنامج على شكل مجموعة أجزاء بتشتغل مع بعض، وبتشارك وتتبادل البيانات؟
دي من أهم الأسئلة في البرمجة.

الاختصار I/O معناه "input/output".
وفي السياق ده، الـoutput من جزء معين من الكود هو الـinput للجزء اللي بعده.
والأجزاء دي بتشارك بيانات مخزنة في الmemory، أو على مساحات تخزين زي الهاردات، أو بتتنقل بال network connections.

ولما نقول "أجزاء من البرنامج"، بنقصد حاجات زي:

1) مثلا function بتاخد شوية arguments وتطلع نتيجة (زي حساب الجذر التربيعي لرقم).
2) أو function بتعمل فعل معين على حاجة مادية (زي رسم خط على الشاشة).
3) أو function بتعدّل جدول معين في البرنامج (زي إضافة اسم جديد لقايمة عملاء).

ولما نقول "input" و"output"، غالبًا بنقصد المعلومات اللي داخلة أو خارجة من computer،
بس زي ما شُفت، ممكن كمان نقصد المعلومات اللي جزء من البرنامج بيستقبلها أو بينتجها.

الـinputs للجزء ده بنسميها غالبًا arguments، والـoutputs بنسميها results.

والمقصود بـcomputation ببساطة هو إنتاج output معين بناءً على input معين،
زي إنتاج الرقم 49 من الرقم 7 باستخدام function اسمها pow (اختصار لpower).

وبالمناسبة، معلومة ممكن تهمك: لحد الخمسينات، كلمة "computer" كانت بتوصف شخص بيعمل computations يدويًا،
زي المحاسب أو الملاح أو الفيزيائي.
دلوقتي إحنا بنخلّي الـcomputers (بأشكالها المختلفة زي الموبايلات) تعمل الحسابات دي بدلنا.

* الهدف والtools اللي بنستخدمها
شغلانتنا كمبرمجين هي إننا نعبّر عن الـcomputations:
- بشكل صحيح (Correctly)
- بشكل بسيط (Simply)
- بشكل فعال (Efficiently)

خلي بالك من ترتيب القيم دي:
مافيش فايدة من برنامج سريع لو بيطلع نتايج غلط.
وبرضو، البرنامج السريع اللي بيطلع نتايج صحيحه ممكن يبقى معقد لدرجة إنه لازم يتكتب من أول وجديد علشان نعمل إصدار جديد منه.
لأن افتكر دايمًا إن البرامج المفيدة بيتم تعديلها بشكل مستمر علشان تواكب احتياجات جديدة أو أجهزة جديدة.
عشان كده، لازم أي برنامج – وأي جزء من البرنامج – يكون بسيط قدر الإمكان في أداء وظيفته.

مثلًا، افترض إنك كتبت برنامج ممتاز لتعليم الحساب للأطفال في مدرسة، لكن الهيكل الداخلي بتاعه فوضوي.
كنت بتتكلم مع الأطفال بأي لغة؟ إنجليزي؟ إنجليزي وإسباني؟
طب لو أنا عايز أستخدمه في فنلندا؟ أو في الكويت؟
هتغير اللغة الطبيعية اللي البرنامج بيخاطب بيها الطفل إزاي؟
لو الهيكل الداخلي للبرنامج فوضوي، العملية اللي منطقها بسيط (لكن في الواقع بتكون صعبة جدًا) زي تغيير لغة البرنامج، هتبقى مستحيلة.

الاهتمام بالبساطة والفعالية بيبدأ أول ما نقرر نكتب كود للناس، ونتحمل مسؤولية إننا نكتبه بشكل كويس. لازم نتحمل المسؤولية دي لما نقرر نبقى محترفين.
بشكل عملي، ده معناه إننا ماينفعش نرمي كود عشوائي لحد ما "يشتغل"، لازم نهتم بالهيكل أو الstructure بتاع الكود.

وعلى عكس المتوقع، الاهتمام بالـstructure وجودة الكود هو غالبًا أسرع طريق علشان نخلي البرنامج يشتغل.
لما البرمجة تتعمل بشكل صح، الاهتمام ده بيقلل من أكتر جزء بضان في البرمجة: debugging.
يعني، هيكل الكود الجيد وقت الكتابة ممكن يقلل عدد الأخطاء، والوقت اللي هنقضيه بندوّر على الأخطاء ونصلحها.

أهم أداة عندنا لتنظيم البرنامج – وتنظيم تفكيرنا وقت البرمجة – هي إننا نقسم المشكله الكبيره لمشاكل صغيره.
الطريقة دي ليها شكلين رئيسيين:

+ الAbstraction:
  بنخبي التفاصيل اللي مش محتاجين نعرفها علشان نستخدم حاجة (يعني "implementation details") ورا interface يكون بسيط وعام.
  مثال: بدل ما ندخل في تفاصيل عمليه الsorting دليل تليفونات (ودي تفاصيل ممكن تكتب عنها كتب)،
  إحنا ببساطة بنستدعي sort algorithm من الC++ standard library.
  كل اللي محتاجين نعرفه هو إزاي ننادي الfunction اللي اسمها =(b)std::sort= ، والـb هو دليل التليفونات.
  مثال تاني: إحنا مش بنتعامل مباشرة مع الmemory – لأنها فوضوية – بل بنستخدم typed variables، أو vectors، أو maps.
+ تكنيك Divide-and-conquer:
  بنقسم المشكلة الكبيرة لمجموعة مشاكل أصغر. مثال: لو عايز تبني قاموس، ممكن تقسم المهمة لثلاثة:
  - اقرأ البيانات
  - رتّب البيانات
  - اطبع البيانات
  كل مهمة من دول أبسط بكتير من المشكلة الأصلية.

ليه الطريقة دي فعالة؟
رغم إن البرنامج اللي متقسم ممكن يكون أطول شوية من برنامج كله محشور ومتلصم مع بعضه بأعجوبه.
بس الحقيقة إننا كبشر مش بنعرف نتعامل كويس مع المشاكل الكبيرة.
في البرمجة – وفي الحياة – بنحل المشاكل الكبيرة عن طريق تقسيمها لأجزاء أصغر وأسهل.
يعني مثلًا، برنامج فيه 1000 سطر ممكن يكون فيه أكتر من 10 أضعاف عدد الأخطاء اللي في برنامج من 100 سطر.
علشان كده بنحاول نخلي البرنامج الطويل مكون من أجزاء صغيرة، كل جزء أقل من 100 سطر. وكل جذء بيتعامل مع مشكله معينه وبيحلها وملوش علاقه بالمشاكل التانيه.

في البرامج الكبيرة اللي بتوصل مئات الألاف او حتي ملايين السطور من الكود.
استخدام abstraction وdivide-and-conquer مش مجرد اختيار، دي ضرورة.
إحنا ببساطة مش قادرين نكتب ونحافظ على برامج ضخمة ومترابطة في كود واحد.
ممكن تبص لبقية الكورس ده على إنه سلسلة طويلة من أمثلة لمشاكل محتاجة تتقسم،
ومعها الأدوات والأساليب اللي تساعدك تعمل كده.

لاحظ التركيز على structure وorganization:
إنت مش هتطلع كود كويس لمجرد إنك كتبت سطور كتير.
كتير جدا من المبتدئين والهاكرز بيفتخروا بعدد السطور اللي كتبوها، فاكرين ان كل لما البرنامج كبر دا بيديله هيبه اكتر.
بس متتفاجئش لما تعرض البرنامج بتاعك اللي بيتكون من الف سطر علي مبرمج محترف وتلاقيه رجعهولك بعد حذف 900 سطر واضافه 200 علشان يكون الناتج 300 سطر بس.
وفي عالم البرمجه، لو في برنامجين بيعملوا نفس الشيئ بس واحد منهم بيتكون من عدد سطور اقل، غالبا البرنامج الأصغر بيكون افضل.

ليه بنتكلم عن ده دلوقتي؟
علشان في المرحلة دي، انت لسه معندكش اي فكره يعني ايه كود حقيقي.
وفيها علي الأقل شهور قبل ما تكتب كود ممكن الناس تعتمد عليه في شغلهم أو حياتهم.
إحنا بنقول الكلام ده علشان نوجّه تركيزك من الأول في الأتجاه الصح والmindset الصح في تصميم البرامج.

من المغري إنك تجري بسرعة وتركز على الحاجات العملية اللي هتستخدمها فورًا،
وتتجاهل الأجزاء الsoft أو النظريه من فن تطوير البرمجيات.
لكن المبرمجين والمصممين المحترفين (وأغلبهم اتعلم ده بالطريقة الصعبة، وهي نفس الطريقه اللي هنحاول نعلمك بيها)
عارفين إن الاهتمام بالstructure هو اهم شيئ في الsoftware الجيد،
وإن تجاهله بيؤدي لكوارث مكلفة.

من غير structure، فـإنت – بشكل مجازي – بتبني بطوب طين.
ينفع؟ آه، لكن عمرك ما هتوصل للدور العاشر (الطوب الطين ما يقدرش يشيل).

لو عندك طموح تبني حاجة كبيرة أو دائمة،
لازم تهتم بهيكل الكود وتنظيمه من الأول،
بدل ما تضطر تتعلمه بعد ما تقع.

* الexpressions
الexpressions هي ابسط building block في البرمجه، الexpression ببساطه بيحسب value من مجموعه من الoperands.

ابسط expression عندنا هو ببساطه literal value زي مثلا 10 أو 'a' أو 3.14 او "Nora".

اسامي الvariables ايضا تعتبر expressions، الvariable هو اسم بيشير لobject معين، يعني مجرد اسم لobject.

علي سبيل المثال بص الكود دا:

#+begin_src C++
int length = 20; // 20 is a literal integer (used to initialize a variable)
int width = 40;
int area = length∗width; // a multiplication
#+end_src

هنا الliterals بتوعنا 20 و 40 بنستخدمهم علشان نعمل initialization للvariables اللي اسمهم length و width، وبعدها بنضربهم.

بمعني اننا بنضرب القيم الموجوده في length بالقيمه اللي موجوده في width، هنا مثلا length ما هي الا اختصار ل: "القيمه اللي موجوده في الobject اللي اسمه length".

وأيضا مثلا:

#+begin_src C++
length = 99; // assign 99 to length
#+end_src

هنا التعبير اللي علي شمال الassignment operator اللي هو length معناه: "الobject اللي اسمه length"، وده بيخلي عمليه الassignment دي تتقرأ: "حط 99 في الobject اللي اسمه length".

فلاحظ الفرق بين معني length لما تستخدمها علي يمين الassignment operator وعلي شماله (as an lvalue and rvalue).

نقدر نعمل expressions اكثر تعقيدا شويه باستخدام بعض الbinary operators اللي اتعودنا عليها زي + أو * وممكن لو احتاجنا نعملهم grouping باستخدام الاقواس:

#+begin_src C++
int perimeter = (length + width) ∗ 2; // add then multiply
#+end_src

بدون الأقواس هنضطر نقول:

#+begin_src C++
int perimeter = length * 2 + width * 2;
#+end_src

بمعني اننا هضرب كل واحد فيهم في اتنين الأول بعدها نعمل الجمع، دي basic arithmetic، بس لاحظ اننا كان ممكن نعمل الغلطه دي:

#+begin_src C++
int perimeter = length + width * 2; // add width * 2 to length
#+end_src

اخر ايرور دا بيتقال عليه logical error، بمعني ان الcompiler هيcompile عادي والlinker هي link عادي بس البرنامج مش هيعمل المطلوب منه، وده بسبب غلطه منطقيه انت عملتها في الكود، وغالبا الerrors دي بتكون اصعب errors انك تكتشفها وتصلحها. علشان كدا القاعده في حوار الexpressions دا تحديدا انك لو قلقان، حط اقواس. بس في نفس الوقت حاول تتعلم بقدر الامكان عن الoperator presence بحيث انك تقلل الأقواس عندك في الكود لأن كتير الأقواس بيقلل الreadability بتاعه الكود بتاعك.

* الconstant expressions
البرامج معظم الوقت بتستخدم ثوابت كتير، وهنا كلمه ثوابت معناها قيم ثابته مش بتتغير علي مدار البرنامج علي عكس المتغيرات، علي سبيل المثال، برنامج هندسي هتلاقيه بيستخدم pi او ثابت بيحول من mile لkilometer واللي غالبا هيبقي حاجه زي 1.609، طبعا احنا هنبقي عايزين اسامي للكلام دا، زي ما قلنا pi مقلناش 3.14159، كذلك مش هقعد كل شويه في الكود اكتب الأرقام دي، وبرضو زي ما انت شايف pi عمرها ما هتتغير، فاحنا عايزين طريقه نقدر بيها نعرف اسم جديد مثلا للبرنامج يبقي pi ويبقي فيه القيمه 3.14159 ومتتغيرش ابدا علي مدار البرنامج، علشان كدا ال++C فيها مفهوم الsymbolic constant وده باختصار named object متقدرش تغير قيمته بعد الinitialization، زي كدا مثلا:

#+begin_src C++
constexpr double PI = 3.14159;
PI = 7; // error : assignment to constant
double c = 2 * PI * r; // OK: we just read pi; we don’t try to change it
#+end_src

هنا بيتقال علي PI دي symbolic constant، وزي ما انت شايف بنعرفاه بالkeyword بتاعتنا =constexpr= ولاحظ برضو ان PI هنا uppercase بمعني ان كل حروفها capital، دا مش ضروري علشان تعمل symbolic constant. بس دا style الC++ developers تبنوه علشان لما تشوف اسم في الكود كل حروفه كابيتال تعرف ان دا symbolic constant.

الsymbolic constants دي مهمه جدا علشان تخلي الكود بتاعك readable، انت ممكن تكون خدت بالك ان 3.14159 دي تقريب ل pi، بس هل كنت هتعرف حاجه زي مثلا 299792458؟ وبرضو لو حد قالك اننا عايزين نغير الكود علشان يستخدم pi ب12 رقم بدل 6 بس، هل هتعدل الرقم في كل مكان عندك في الكود؟ اكيد هيبقي اسهل بكتير انك بس تعمل كدا:

#+begin_src C++
constexpr double pi = 3.14159265359;
#+end_src

علشان كدا احنا بنحاول علي قد ما نقدر اننا نقلل استخدام الliterals في الكود بتاعنا علي قد ما نقد (الا طبعا لو بنعرف بيهم constants)، الliterals برا الdefinition of constants بيتقال عليهم *magic numbers*

وبالمناسبه 299792458 دا ثابت كوني، سرعه الضوء في الفراغ متقاسه بالمتر علي الثانيه، لو انت مقدرتش تعرف دا لحظيا، ليه متوقع انك ممكن متتلخبطش من literals كتير مدموجه في الكود بتاعك؟ تجنب الmagic constants!

ال =constexpr= لازم يتعرفله قيمه محدده وقت الcompile time، بمعني انك لو عندك =constexpr= في الكود بتاعك وجيت تcompile والcompiler مقدرش انه يحدد قيمته ايه وقت الcompilation هيطلعلك error:

#+begin_src C++
constexpr int MAX = 100;
int n;
std::cin >> n; // value of n is only aquired at runtime
constexpr int C1 = MAX + 7; // OK: c1 is 107
constexpr int C2 = n + 7; // error : we don’t know the value of n until runtime
#+end_src

انما لو عندك حاله انت عايز تعمل فيها constant بيتعمله initialization بvalue مش هتبقي معروفه في الcompile time، ال++C بتقدملك مفهوم للconstants اسمه =const=:

#+begin_src C++
int n;
std::cin >> n;
const int c3 = 3 + n; // this is ok
c3 = 7; // error: c3 is a constant an cannot be reassigned
#+end_src

والنوع دا من الconstants مشهور جدا ومستخدم بكثره

* الoperators
إحنا لحد الان بنستخدم أبسط الـ operators. بس قريب هتحتاج تستخدم أكتر علشان تقدر تعبّر عن عمليات أعقد. أغلب الـ operators مشهورة ومعروفة، فهنشرحهم بعدين وقت ما تحتاجهم، وكمان تقدر تدور على التفاصيل بنفسك وقت ما تحتاجهم. دا جدول من الكتاب بكتير من الoperators الشائعه:

[[../images/operators3.png]]
[[../images/operators4.png]]
